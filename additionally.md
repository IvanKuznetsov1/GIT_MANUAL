[На главную.](readme.md)

# Дополнительно.
## 1. Отслеживание изменений, сделанных в коммитах.

У каждого коммита есть свой уникальный идентификатор в виде строки цифр и букв. Чтобы просмотреть список всех коммитов и их идентификаторов, можно использовать команду log:
[spoiler title='Вывод git log']

    $ git log
    commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7
    Author: Tutorialzine
    Date: Mon April 2 17:15:28 2022 +0300
    New feature complete
    commit b10cc1238e355c02a044ef9f9860811ff605c9b4
    Author: Tutorialzine
    Date: Mon April 2 16:30:04 2022 +0300
    Added content to hello.txt
    commit 09bd8cc171d7084e78e4d118a2346b7487dca059
    Author: Tutorialzine
    Date: Sat April 1 17:52:14 2022 +0300
    Initial commit

    
## 2. Возвращение файла к предыдущему состоянию.

Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Это делается уже знакомой нам командой checkout, которую мы ранее использовали для переключения между ветками. Но она также может быть использована для переключения между коммитами (это довольно распространенная ситуация для Гита - использование одной команды для различных, на первый взгляд, слабо связанных задач).
В следующем примере мы возьмем файл hello.txt и откатим все изменения, совершенные над ним к первому коммиту. Чтобы сделать это, мы подставим в команду идентификатор нужного коммита, а также путь до файла:

    $ git checkout 09bd8cc1 hello.txt

## 3. Исправление коммита.

Если вы опечатались в комментарии или забыли добавить файл и заметили это сразу после того, как закоммитили изменения, вы легко можете это поправить при помощи commit —amend. Эта команда добавит все из последнего коммита в область подготовленных файлов и попытается сделать новый коммит. Это дает вам возможность поправить комментарий или добавить недостающие файлы в область подготовленных файлов.
Для более сложных исправлений, например, не в последнем коммите или если вы успели отправить изменения на сервер, нужно использовать revert. Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным идентификатором.
Самый последний коммит может быть доступен по алиасу HEAD:

    $ git revert HEAD

Для остальных будем использовать идентификаторы:

    $ git revert b10cc123

При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь git не может найти строчки, состояние которых нужно откатить, так как они больше не существуют. 

## 4. Разрешение конфликтов при слиянии.

Помимо сценария, описанного в предыдущем пункте, конфликты регулярно возникают при слиянии ветвей или при отправке чужого кода. Иногда конфликты исправляются автоматически, но обычно с этим приходится разбираться вручную — решать, какой код остается, а какой нужно удалить.
Давайте посмотрим на примеры, где мы попытаемся слить две ветки под названием john_branch и tim_branch. И Тим, и Джон правят один и тот же файл: функцию, которая отображает элементы массива.
Джон использует цикл:

    // Use a for loop to console.log contents.
    for(var i=0; i<arr.length; i++) {
    console.log(arr[i]);
    }

Тим предпочитает forEach:

    // Use forEach to console.log contents.
    arr.forEach(function(item) {
    console.log(item);
    });

Они оба коммитят свой код в соответствующую ветку. Теперь, если они попытаются слить две ветки, они получат сообщение об ошибке:

    $ git merge tim_branch
    Auto-merging print_array.js
    CONFLICT (content): Merge conflict in print_array.js
    Automatic merge failed; fix conflicts and then commit the result.

Система не смогла разрешить конфликт автоматически, значит, это придется сделать разработчикам. Приложение отметило строки, содержащие конфликт:
[spoiler title='Вывод']

    <<<<<<< HEAD // Use a for loop to console.log contents. for(var i=0; i<arr.length; i++) { console.log(arr[i]); } ======= // Use forEach to console.log contents. arr.forEach(function(item) { console.log(item); }); >>>>>>> Tim's commit.

[/spoiler]
Над разделителем ======= мы видим последний (HEAD) коммит, а под ним - конфликтующий. Таким образом, мы можем увидеть, чем они отличаются и решать, какая версия лучше. Или вовсе написать новую. В этой ситуации мы так и поступим, перепишем все, удалив разделители, и дадим git понять, что закончили.

    // Not using for loop or forEach.
    // Use Array.toString() to console.log contents.
    console.log(arr.toString());

Когда все готово, нужно закоммитить изменения, чтобы закончить процесс:

    $ git add -A
    $ git commit -m "Array printing conflict resolved."

Как вы можете заметить, процесс довольно утомительный и может быть очень сложным в больших проектах. Многие разработчики предпочитают использовать для разрешения конфликтов клиенты с графическим интерфейсом. (Для запуска нужно набрать git mergetool).

[Следующая.](the_end.md)